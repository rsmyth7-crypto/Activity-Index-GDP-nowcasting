# -*- coding: utf-8 -*-
"""4.RFNowcastingmodelandvalidation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qd1GNeVKUP3nzX-pAC8oyc5P2_onZYGY

# Random Forest Regression

### **Random Forest regression for whole data set**
"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error
import numpy as np
import pandas as pd  # Import pandas for DataFrame creation

# Create lagged GDP and GDP growth features
df['GDP_lag1'] = df['GDP'].shift(1)
df['GDP_growth'] = df['GDP'].pct_change()

# Drop rows with NaN values that result from lagging/pct_change
df_model = df.dropna(subset=['GDP_lag1', 'GDP_growth', 'hospitality_index'])

X = df_model[['GDP_lag1', 'hospitality_index']]
y = df_model['GDP_growth']

tscv = TimeSeriesSplit(n_splits=5)

all_preds = []
all_actuals = []
all_dates = []  # To store dates for each prediction

for train_idx, test_idx in tscv.split(X):
    X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
    y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]

    rf = RandomForestRegressor(n_estimators=500, random_state=42)
    rf.fit(X_train, y_train)

    pred = rf.predict(X_test)
    all_preds.extend(pred)
    all_actuals.extend(y_test.tolist())  # Convert Series to list
    all_dates.extend(y_test.index.tolist())  # Store dates

# Create a DataFrame for easier plotting and filtering
nowcast_results_df = pd.DataFrame({
    'date': all_dates,
    'actual': all_actuals,
    'predicted': all_preds,
}).set_index('date').sort_index()

rmse = np.sqrt(mean_squared_error(all_actuals, all_preds))
print("RF RMSE:", rmse)

"""###**Create graph for Full time period of nowcasting**"""

import matplotlib.pyplot as plt
import pandas as pd

plt.figure(figsize=(12, 6))
plt.plot(nowcast_results_df.index, nowcast_results_df['actual'], label="Actual GDP Growth")
plt.plot(nowcast_results_df.index, nowcast_results_df['predicted'], label="Predicted GDP Growth")
plt.legend()
plt.title("Nowcast vs Actual GDP Growth (Full Dataset)")
plt.xlabel("Date")
plt.ylabel("GDP Growth")
plt.grid(True)
plt.show()

"""### **Random Forest Regression - Trained on Last 5 Years of Data**"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error
import numpy as np
import pandas as pd

# Ensure df has the latest lagged and growth features
df['GDP_lag1'] = df['GDP'].shift(1)
df['GDP_growth'] = df['GDP'].pct_change()

# Drop rows with NaN values that result from lagging/pct_change for the full dataset
df_model_full = df.dropna(subset=['GDP_lag1', 'GDP_growth', 'hospitality_index'])

# Filter df_model for only the last five years for training
five_years_ago_train = df_model_full.index.max() - pd.DateOffset(years=5)
df_model_5_years_train = df_model_full[df_model_full.index >= five_years_ago_train]

X_5_years_train = df_model_5_years_train[['GDP_lag1', 'hospitality_index']]
y_5_years_train = df_model_5_years_train['GDP_growth']

tscv_5_years = TimeSeriesSplit(n_splits=3)  # Reduced splits for potentially smaller dataset

all_preds_5_years = []
all_actuals_5_years = []
all_dates_5_years = []

for train_idx, test_idx in tscv_5_years.split(X_5_years_train):
    X_train_5_years, X_test_5_years = X_5_years_train.iloc[train_idx], X_5_years_train.iloc[test_idx]
    y_train_5_years, y_test_5_years = y_5_years_train.iloc[train_idx], y_5_years_train.iloc[test_idx]

    rf_5_years = RandomForestRegressor(n_estimators=500, random_state=42)
    rf_5_years.fit(X_train_5_years, y_train_5_years)

    pred_5_years = rf_5_years.predict(X_test_5_years)
    all_preds_5_years.extend(pred_5_years)
    all_actuals_5_years.extend(y_test_5_years.tolist())
    all_dates_5_years.extend(y_test_5_years.index.tolist())

# Create a DataFrame for results specific to this 5-year training
nowcast_results_df_5_years_trained = pd.DataFrame({
    'date': all_dates_5_years,
    'actual': all_actuals_5_years,
    'predicted': all_preds_5_years,
}).set_index('date').sort_index()

rmse_5_years_trained = np.sqrt(mean_squared_error(all_actuals_5_years, all_preds_5_years))
print("RF RMSE (Model Trained Only on Last 5 Years Data):", rmse_5_years_trained)

"""Create graph for model trained on 5 years of data"""

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(nowcast_results_df_5_years_trained.index, nowcast_results_df_5_years_trained['actual'], label="Actual GDP Growth")
plt.plot(nowcast_results_df_5_years_trained.index, nowcast_results_df_5_years_trained['predicted'], label="Predicted GDP Growth")
plt.legend()
plt.title("Nowcast vs Actual GDP Growth (Model Trained on Last 5 Years)")
plt.xlabel("Date")
plt.ylabel("GDP Growth")
plt.grid(True)
plt.show()

"""###**Save RFR models**"""

import os

results_folder = os.path.join(project_root, 'results')
os.makedirs(results_folder, exist_ok=True)

# Save the full dataset nowcasting results
nowcast_full_path = os.path.join(results_folder, 'nowcast_results_full_dataset.csv')
nowcast_results_df.to_csv(nowcast_full_path)
print(f"Full dataset nowcasting results saved to: {nowcast_full_path}")

# Save the nowcasting results from the model trained on the last five years
nowcast_5yr_trained_path = os.path.join(results_folder, 'nowcast_results_5_years_trained.csv')
nowcast_results_df_5_years_trained.to_csv(nowcast_5yr_trained_path)
print(f"Nowcasting results (model trained on last 5 years) saved to: {nowcast_5yr_trained_path}")

"""**Model Validation**"""

import pandas as pd
import numpy as np
from sklearn.metrics import mean_absolute_error
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor

# --- Calculate MAE for the full dataset nowcasting model ---
# nowcast_results_df is available from jXDIeJxOyn2Z
if 'nowcast_results_df' in locals() and not nowcast_results_df.empty:
    mae_full = mean_absolute_error(nowcast_results_df['actual'], nowcast_results_df['predicted'])
    print(f"Full Dataset Nowcasting - Mean Absolute Error (MAE): {mae_full:.4f}")
    nowcast_results_df['residuals'] = nowcast_results_df['actual'] - nowcast_results_df['predicted']
else:
    print("nowcast_results_df not found or empty. Please ensure the full dataset RF cell (jXDIeJxOyn2Z) has been run.")
    mae_full = None # Set to None if not calculated

# --- Calculate MAE for the 5-year trained model ---
# nowcast_results_df_5_years_trained is available from fd881ec4
if 'nowcast_results_df_5_years_trained' in locals() and not nowcast_results_df_5_years_trained.empty:
    mae_5_years_trained = mean_absolute_error(nowcast_results_df_5_years_trained['actual'], nowcast_results_df_5_years_trained['predicted'])
    print(f"\n5-Year Trained Nowcasting - Mean Absolute Error (MAE): {mae_5_years_trained:.4f}")
    nowcast_results_df_5_years_trained['residuals'] = nowcast_results_df_5_years_trained['actual'] - nowcast_results_df_5_years_trained['predicted']
else:
    print("\nnowcast_results_df_5_years_trained not found or empty. Please ensure the 5-year trained RF cell (fd881ec4) has been run.")
    mae_5_years_trained = None # Set to None if not calculated

# --- Determine global y-limits for consistent residual plot scaling ---
all_residuals = pd.Series([]) # Initialize empty series
if 'nowcast_results_df' in locals() and 'residuals' in nowcast_results_df.columns:
    all_residuals = pd.concat([all_residuals, nowcast_results_df['residuals']])
if 'nowcast_results_df_5_years_trained' in locals() and 'residuals' in nowcast_results_df_5_years_trained.columns:
    all_residuals = pd.concat([all_residuals, nowcast_results_df_5_years_trained['residuals']])

if not all_residuals.empty:
    y_min_global = all_residuals.min() * 1.1 # Add a little padding
    y_max_global = all_residuals.max() * 1.1 # Add a little padding
else:
    y_min_global, y_max_global = -0.05, 0.05 # Default if no residuals are found


# --- Train a final RF model on the full dataset for Feature Importance ---
# Assumes X and y are available from cell jXDIeJxOyn2Z
if 'X' in locals() and 'y' in locals():
    rf_final = RandomForestRegressor(n_estimators=500, random_state=42)
    rf_final.fit(X, y)
    print("\nFeature Importances for Full Dataset Random Forest Model:")
    feature_importances = pd.Series(rf_final.feature_importances_, index=X.columns)
    print(feature_importances.sort_values(ascending=False))
else:
    print("\nX and y for full dataset not found. Please ensure cell jXDIeJxOyn2Z has been run.")
    feature_importances = None

# --- Train a final RF model on the 5-year dataset for Feature Importance ---
# Assumes X_5_years_train and y_5_years_train are available from cell fd881ec4
if 'X_5_years_train' in locals() and 'y_5_years_train' in locals():
    rf_5_years_fi = RandomForestRegressor(n_estimators=500, random_state=42)
    rf_5_years_fi.fit(X_5_years_train, y_5_years_train)
    print("\nFeature Importances for 5-Year Random Forest Model:")
    feature_importances_5_years = pd.Series(rf_5_years_fi.feature_importances_, index=X_5_years_train.columns)
    print(feature_importances_5_years.sort_values(ascending=False))
else:
    print("\nX_5_years_train and y_5_years_train for 5-year model not found. Please ensure cell fd881ec4 has been run.")
    feature_importances_5_years = None

import os
import matplotlib.pyplot as plt
import pandas as pd

# Define the path to the models folder
models_folder = os.path.join(project_root, 'models')
os.makedirs(models_folder, exist_ok=True)

# --- Save Residual Plots ---

# 1. Residual Plot for Full Dataset
# Assumes nowcast_results_df has 'residuals' column and y_min_global/y_max_global are set in the previous cell (FkfwguC6U-cy)
if 'nowcast_results_df' in locals() and not nowcast_results_df.empty and 'residuals' in nowcast_results_df.columns:
    plt.figure(figsize=(12, 6))
    plt.plot(nowcast_results_df.index, nowcast_results_df['residuals'], label="Residuals")
    plt.axhline(0, color='red', linestyle='--', linewidth=0.8)
    plt.legend()
    plt.title("Residuals of Nowcast vs Actual GDP Growth (Full Dataset)")
    plt.xlabel("Date")
    plt.ylabel("Residuals (Actual - Predicted)")
    # Use global limits if available, otherwise determine for this plot
    if 'y_min_global' in locals() and 'y_max_global' in locals():
        plt.ylim(y_min_global, y_max_global)
    plt.grid(True)
    full_residuals_path = os.path.join(models_folder, 'full_dataset_residuals.png')
    plt.savefig(full_residuals_path)
    plt.close() # Close plot to free up memory
    print(f"Full dataset residuals plot saved to: {full_residuals_path}")
else:
    print("Cannot save full dataset residuals plot: nowcast_results_df or its 'residuals' not found or empty.")


# 2. Residual Plot for 5-Year Trained Model
# Assumes nowcast_results_df_5_years_trained has 'residuals' column and y_min_global/y_max_global are set in the previous cell (FkfwguC6U-cy)
if 'nowcast_results_df_5_years_trained' in locals() and not nowcast_results_df_5_years_trained.empty and 'residuals' in nowcast_results_df_5_years_trained.columns:
    plt.figure(figsize=(12, 6))
    plt.plot(nowcast_results_df_5_years_trained.index, nowcast_results_df_5_years_trained['residuals'], label="Residuals")
    plt.axhline(0, color='red', linestyle='--', linewidth=0.8)
    plt.legend()
    plt.title("Residuals of Nowcast vs Actual GDP Growth (Model Trained on Last 5 Years)")
    plt.xlabel("Date")
    plt.ylabel("Residuals (Actual - Predicted)")
    # Use global limits if available, otherwise determine for this plot
    if 'y_min_global' in locals() and 'y_max_global' in locals():
        plt.ylim(y_min_global, y_max_global)
    plt.grid(True)
    five_year_residuals_path = os.path.join(models_folder, 'five_year_trained_residuals.png')
    plt.savefig(five_year_residuals_path)
    plt.close() # Close plot
    print(f"5-year trained residuals plot saved to: {five_year_residuals_path}")
else:
    print("Cannot save 5-year trained residuals plot: nowcast_results_df_5_years_trained or its 'residuals' not found or empty.")


# --- Save Feature Importances ---
# Assumes feature_importances is calculated in the previous cell (FkfwguC6U-cy)
if 'feature_importances' in locals() and feature_importances is not None:
    feature_importances_path_full = os.path.join(models_folder, 'feature_importances_full_dataset.txt')
    with open(feature_importances_path_full, 'w') as f:
        f.write("Feature Importances for Full Dataset Random Forest Model:\n")
        f.write(feature_importances.sort_values(ascending=False).to_string())
    print(f"Feature importances for full dataset saved to: {feature_importances_path_full}")
else:
    print("Feature importances for full dataset not found.")

# Assumes feature_importances_5_years is calculated in the previous cell (FkfwguC6U-cy)
if 'feature_importances_5_years' in locals() and feature_importances_5_years is not None:
    feature_importances_path_5_years = os.path.join(models_folder, 'feature_importances_5_years.txt')
    with open(feature_importances_path_5_years, 'w') as f:
        f.write("Feature Importances for 5-Year Random Forest Model:\n")
        f.write(feature_importances_5_years.sort_values(ascending=False).to_string())
    print(f"Feature importances for 5-year model saved to: {feature_importances_5_years}")
else:
    print("Feature importances for 5-year model not found.")


# --- Save MAE Values ---
mae_values_path = os.path.join(models_folder, 'mae_values.txt')
with open(mae_values_path, 'w') as f:
    if 'mae_full' in locals() and mae_full is not None:
        f.write(f"Full Dataset Nowcasting - Mean Absolute Error (MAE): {mae_full:.4f}\n")
    else:
        f.write("Full Dataset Nowcasting - Mean Absolute Error (MAE): Not calculated\n")
    if 'mae_5_years_trained' in locals() and mae_5_years_trained is not None:
        f.write(f"5-Year Trained Nowcasting - Mean Absolute Error (MAE): {mae_5_years_trained:.4f}\n")
    else:
        f.write("5-Year Trained Nowcasting - Mean Absolute Error (MAE): Not calculated\n")
print(f"MAE values saved to: {mae_values_path}")

"""## Train RF Model with GDP_lag1 only



"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error
import numpy as np
import pandas as pd

# 1. Ensure the DataFrame df has the GDP_lag1 and GDP_growth columns
# These columns are typically created earlier in the notebook, but ensure they exist
# for robustness.
if 'GDP_lag1' not in df.columns:
    df['GDP_lag1'] = df['GDP'].shift(1)
if 'GDP_growth' not in df.columns:
    df['GDP_growth'] = df['GDP'].pct_change()

# 2. Create a new DataFrame by dropping rows with NaN values from df
df_model_gdp_only = df.dropna(subset=['GDP_lag1', 'GDP_growth'])

# 3. Define the feature matrix X_gdp_only using only the 'GDP_lag1' column
X_gdp_only = df_model_gdp_only[['GDP_lag1']]

# 4. Define the target vector y_gdp_only using the 'GDP_growth' column
y_gdp_only = df_model_gdp_only['GDP_growth']

# 5. Initialize TimeSeriesSplit with n_splits=5
tscv_gdp_only = TimeSeriesSplit(n_splits=5)

# 6. Create empty lists to store all predictions, all actuals, and corresponding dates
all_preds_gdp_only = []
all_actuals_gdp_only = []
all_dates_gdp_only = []

# 7. Loop through each train and test index generated by the TimeSeriesSplit
for train_idx, test_idx in tscv_gdp_only.split(X_gdp_only):
    # 8. For each split, create X_train, X_test, y_train, and y_test subsets
    X_train_gdp_only, X_test_gdp_only = X_gdp_only.iloc[train_idx], X_gdp_only.iloc[test_idx]
    y_train_gdp_only, y_test_gdp_only = y_gdp_only.iloc[train_idx], y_gdp_only.iloc[test_idx]

    # 9. Initialize a RandomForestRegressor model
    rf_gdp_only = RandomForestRegressor(n_estimators=500, random_state=42)

    # 10. Fit the Random Forest model to the training data
    rf_gdp_only.fit(X_train_gdp_only, y_train_gdp_only)

    # 11. Make predictions on the test data
    pred_gdp_only = rf_gdp_only.predict(X_test_gdp_only)

    # 12. Extend the lists
    all_preds_gdp_only.extend(pred_gdp_only)
    all_actuals_gdp_only.extend(y_test_gdp_only.tolist())
    all_dates_gdp_only.extend(y_test_gdp_only.index.tolist())

# 13. After the loop, create a pandas DataFrame
nowcast_results_df_gdp_only = pd.DataFrame({
    'date': all_dates_gdp_only,
    'actual': all_actuals_gdp_only,
    'predicted': all_preds_gdp_only,
}).set_index('date').sort_index()

# 14. Calculate the Root Mean Squared Error (RMSE)
rmse_gdp_only = np.sqrt(mean_squared_error(all_actuals_gdp_only, all_preds_gdp_only))

# 15. Print the calculated RMSE
print("RF RMSE (GDP_lag1 only model):", rmse_gdp_only)

"""## Compare Model Performance (Full data set)


"""

print(f"RMSE for Random Forest (GDP_lag1 only): {rmse_gdp_only:.4f}")
print(f"RMSE for Random Forest (GDP_lag1 and hospitality_index): {rmse:.4f}")

"""## Train RF Model with GDP_lag1 only (last 5 years)


"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error
import numpy as np
import pandas as pd

# 1. Ensure the DataFrame df has the GDP_lag1 and GDP_growth columns
# These columns are typically created earlier in the notebook, but ensure they exist
# for robustness.
if 'GDP_lag1' not in df.columns:
    df['GDP_lag1'] = df['GDP'].shift(1)
if 'GDP_growth' not in df.columns:
    df['GDP_growth'] = df['GDP'].pct_change()

# 2. Filter the df DataFrame to include only the last five years of data.
last_available_date_5yr = df.index.max()
five_years_ago_5yr = last_available_date_5yr - pd.DateOffset(years=5)
df_5_years_gdp_only = df[df.index >= five_years_ago_5yr]

# 3. Create a new DataFrame by dropping any rows with NaN values
df_model_gdp_only_5_years = df_5_years_gdp_only.dropna(subset=['GDP_lag1', 'GDP_growth'])

# 4. Define the feature matrix X_gdp_only_5_years using only the 'GDP_lag1' column
X_gdp_only_5_years = df_model_gdp_only_5_years[['GDP_lag1']]

# 5. Define the target vector y_gdp_only_5_years using the 'GDP_growth' column
y_gdp_only_5_years = df_model_gdp_only_5_years['GDP_growth']

# 6. Initialize TimeSeriesSplit with n_splits=3
tscv_gdp_only_5_years = TimeSeriesSplit(n_splits=3)

# 7. Create empty lists to store all predictions, all actuals, and corresponding dates
all_preds_gdp_only_5_years = []
all_actuals_gdp_only_5_years = []
all_dates_gdp_only_5_years = []

# Loop through each train and test index generated by the TimeSeriesSplit
for train_idx, test_idx in tscv_gdp_only_5_years.split(X_gdp_only_5_years):
    # a. Create X_train, X_test, y_train, and y_test subsets
    X_train_gdp_only_5_years, X_test_gdp_only_5_years = X_gdp_only_5_years.iloc[train_idx], X_gdp_only_5_years.iloc[test_idx]
    y_train_gdp_only_5_years, y_test_gdp_only_5_years = y_gdp_only_5_years.iloc[train_idx], y_gdp_only_5_years.iloc[test_idx]

    # b. Initialize a RandomForestRegressor model
    rf_gdp_only_5_years = RandomForestRegressor(n_estimators=500, random_state=42)

    # c. Fit the Random Forest model to the training data
    rf_gdp_only_5_years.fit(X_train_gdp_only_5_years, y_train_gdp_only_5_years)

    # d. Make predictions on the test data
    pred_gdp_only_5_years = rf_gdp_only_5_years.predict(X_test_gdp_only_5_years)

    # e. Store all predictions, actual values, and corresponding dates
    all_preds_gdp_only_5_years.extend(pred_gdp_only_5_years)
    all_actuals_gdp_only_5_years.extend(y_test_gdp_only_5_years.tolist())
    all_dates_gdp_only_5_years.extend(y_test_gdp_only_5_years.index.tolist())

# 8. After the loop, create a pandas DataFrame
nowcast_results_df_gdp_only_5_years = pd.DataFrame({
    'date': all_dates_gdp_only_5_years,
    'actual': all_actuals_gdp_only_5_years,
    'predicted': all_preds_gdp_only_5_years,
}).set_index('date').sort_index()

# 9. Calculate the Root Mean Squared Error (RMSE)
rmse_gdp_only_5_years = np.sqrt(mean_squared_error(all_actuals_gdp_only_5_years, all_preds_gdp_only_5_years))

# 10. Print the calculated RMSE for this 'GDP_lag1' only model trained on the last 5 years.
print(f"RF RMSE (GDP_lag1 only, last 5 years): {rmse_gdp_only_5_years}")

"""## Compare Model Performance (last 5 years)


"""

print(f"RMSE for Random Forest (GDP_lag1 only, last 5 years): {rmse_gdp_only_5_years:.4f}")
print(f"RMSE for Random Forest (GDP_lag1 and hospitality_index, last 5 years): {rmse_5_years_trained:.4f}")